"""
Research Trees - Technology Progression System for AgriFun Agricultural Simulation

This system provides comprehensive research and development progression through technology trees
that unlock new capabilities, equipment, techniques, and agricultural innovations. The system
includes multiple specialized research tracks covering equipment, crop science, sustainability,
precision agriculture, and advanced farming technologies.

Key Features:
- Multi-Track Research System: Equipment, Crop Science, Sustainability, Precision Agriculture
- Technology Dependencies: Realistic prerequisite chains for technological advancement
- Resource Requirements: Research points, funding, time, and facility requirements
- Progressive Unlocks: Gradual advancement through agricultural technology eras
- Innovation Breakthroughs: Special discoveries that unlock new research paths
- Economic Integration: Cost-benefit analysis and ROI tracking for research investments

Educational Value:
- Historical progression of agricultural technology development
- Understanding of interdependencies between different agricultural sciences
- Real-world research timelines and resource requirements
- Economic decision-making in agricultural technology adoption
- Sustainability considerations in technological advancement
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum
import logging
from datetime import datetime, timedelta
import json
import yaml
import random


class ResearchCategory(Enum):
    """Main categories of agricultural research"""
    EQUIPMENT_TECHNOLOGY = "equipment_technology"         # Tractors, implements, machinery
    CROP_SCIENCE = "crop_science"                        # Genetics, breeding, physiology
    SOIL_SCIENCE = "soil_science"                        # Soil health, fertility, conservation
    PRECISION_AGRICULTURE = "precision_agriculture"       # GPS, sensors, data analytics
    SUSTAINABILITY = "sustainability"                     # Organic methods, conservation
    BIOTECHNOLOGY = "biotechnology"                       # GMOs, tissue culture, biotech
    WATER_MANAGEMENT = "water_management"                 # Irrigation, drainage, conservation
    PEST_MANAGEMENT = "pest_management"                   # IPM, biocontrol, resistance
    POST_HARVEST = "post_harvest"                        # Storage, processing, value-added
    FARM_MANAGEMENT = "farm_management"                   # Business, logistics, optimization


class ResearchEra(Enum):
    """Technological eras in agricultural development"""
    TRADITIONAL = "traditional"                          # 1800-1900: Hand tools, animal power
    MECHANIZATION = "mechanization"                      # 1900-1950: Tractors, basic machinery
    CHEMICAL = "chemical"                                # 1950-1980: Fertilizers, pesticides
    PRECISION = "precision"                              # 1980-2010: GPS, computers, sensors
    DIGITAL = "digital"                                  # 2010-2030: IoT, AI, big data
    AUTONOMOUS = "autonomous"                            # 2030+: Full automation, robotics


class ResearchComplexity(Enum):
    """Research complexity levels"""
    BASIC = "basic"                                      # Fundamental concepts, 1-6 months
    INTERMEDIATE = "intermediate"                        # Applied research, 6-18 months
    ADVANCED = "advanced"                               # Complex systems, 1-3 years
    CUTTING_EDGE = "cutting_edge"                       # Breakthrough research, 3-5 years
    REVOLUTIONARY = "revolutionary"                      # Paradigm shifts, 5+ years


class ResearchStatus(Enum):
    """Current status of research projects"""
    LOCKED = "locked"                                    # Prerequisites not met
    AVAILABLE = "available"                              # Can be researched
    IN_PROGRESS = "in_progress"                         # Currently being researched
    COMPLETED = "completed"                             # Research finished
    APPLIED = "applied"                                 # Technology implemented on farm


class ResourceType(Enum):
    """Types of resources required for research"""
    RESEARCH_POINTS = "research_points"                  # Generated by research activities
    FUNDING = "funding"                                  # Money for equipment, materials
    TIME = "time"                                        # Calendar time for completion
    FACILITIES = "facilities"                            # Required research infrastructure
    PARTNERSHIPS = "partnerships"                        # University/company collaborations
    DATA = "data"                                       # Field data, experimental results


@dataclass
class ResearchPrerequisite:
    """Prerequisites for unlocking research"""
    prerequisite_id: str
    prerequisite_type: str                               # "technology", "resource", "achievement"
    required_level: Optional[int] = None                 # For leveled prerequisites
    required_amount: Optional[float] = None              # For resource prerequisites
    description: str = ""


@dataclass
class ResearchResource:
    """Resources required for research"""
    resource_type: ResourceType
    amount_required: float
    amount_consumed: float                               # How much is consumed vs. unlocked
    description: str
    alternative_sources: List[str] = field(default_factory=list)


@dataclass
class ResearchBenefit:
    """Benefits gained from completing research"""
    benefit_type: str                                    # "unlock", "bonus", "efficiency", "new_option"
    benefit_target: str                                  # What the benefit applies to
    benefit_value: float                                 # Magnitude of benefit
    benefit_description: str
    permanent: bool = True                              # Whether benefit persists
    

@dataclass
class ResearchTechnology:
    """Individual research technology node"""
    tech_id: str
    tech_name: str
    description: str
    category: ResearchCategory
    era: ResearchEra
    complexity: ResearchComplexity
    
    # Prerequisites and dependencies
    prerequisites: List[ResearchPrerequisite] = field(default_factory=list)
    unlocks: List[str] = field(default_factory=list)    # Technologies this unlocks
    
    # Resource requirements
    resources_required: List[ResearchResource] = field(default_factory=list)
    base_research_time_days: int = 30                   # Base time to complete
    
    # Benefits and unlocks
    benefits: List[ResearchBenefit] = field(default_factory=list)
    equipment_unlocks: List[str] = field(default_factory=list)
    crop_unlocks: List[str] = field(default_factory=list)
    technique_unlocks: List[str] = field(default_factory=list)
    
    # Research mechanics
    breakthrough_chance: float = 0.05                   # Chance for early completion
    innovation_points_generated: int = 0                # Innovation points this tech generates
    research_efficiency_bonus: float = 0.0             # Bonus to future research speed
    
    # Economic factors
    development_cost: float = 0                         # Cost to develop technology
    implementation_cost: float = 0                      # Cost to implement on farm
    maintenance_cost_annual: float = 0                  # Annual maintenance costs
    roi_estimate_years: float = 5.0                     # Estimated payback period
    
    # Status tracking
    status: ResearchStatus = ResearchStatus.LOCKED
    research_progress: float = 0.0                      # 0-1 completion
    date_started: Optional[datetime] = None
    date_completed: Optional[datetime] = None
    researcher_assigned: Optional[str] = None


@dataclass
class ResearchProject:
    """Active research project tracking"""
    project_id: str
    technology_id: str
    project_name: str
    principal_researcher: str
    
    # Progress tracking
    start_date: datetime
    estimated_completion: datetime
    actual_completion: Optional[datetime] = None
    progress_percentage: float = 0.0
    
    # Resource allocation
    funding_allocated: float = 0
    funding_spent: float = 0
    researchers_assigned: List[str] = field(default_factory=list)
    facilities_used: List[str] = field(default_factory=list)
    
    # Progress milestones
    milestones: List[Dict[str, Any]] = field(default_factory=list)
    challenges_encountered: List[str] = field(default_factory=list)
    breakthrough_opportunities: List[str] = field(default_factory=list)
    
    # Collaboration and partnerships
    external_partners: List[str] = field(default_factory=list)
    knowledge_sharing_agreements: List[str] = field(default_factory=list)


@dataclass
class ResearchFacility:
    """Research facility and infrastructure"""
    facility_id: str
    facility_name: str
    facility_type: str                                  # "lab", "greenhouse", "field_station", "computing"
    
    # Capabilities
    research_categories_supported: List[ResearchCategory]
    max_concurrent_projects: int
    research_efficiency_multiplier: float = 1.0
    
    # Resources and costs
    construction_cost: float
    annual_operating_cost: float
    equipment_value: float
    staff_capacity: int
    
    # Current utilization
    current_projects: List[str] = field(default_factory=list)
    utilization_percentage: float = 0.0
    
    # Upgrade potential
    upgrade_options: List[Dict[str, Any]] = field(default_factory=list)
    technology_level: int = 1


class ResearchTrees:
    """
    Comprehensive Research Trees system for agricultural technology progression
    
    This system manages multiple technology trees across different agricultural disciplines,
    tracking prerequisites, resource requirements, and progressive unlocks that enhance
    farm capabilities and efficiency.
    """
    
    def __init__(self, config_manager=None, event_system=None):
        """Initialize research trees system"""
        self.config_manager = config_manager
        self.event_system = event_system
        self.logger = logging.getLogger(__name__)
        
        # Core research data
        self.technologies: Dict[str, ResearchTechnology] = {}
        self.research_projects: Dict[str, ResearchProject] = {}
        self.research_facilities: Dict[str, ResearchFacility] = {}
        
        # Player progress
        self.completed_technologies: Set[str] = set()
        self.available_technologies: Set[str] = set()
        self.in_progress_technologies: Set[str] = set()
        
        # Resources and progression
        self.research_points: Dict[ResearchCategory, float] = {}
        self.innovation_points: float = 0
        self.total_research_funding: float = 0
        self.research_efficiency_multiplier: float = 1.0
        
        # Research personnel
        self.research_staff: Dict[str, Dict[str, Any]] = {}
        self.external_partnerships: Dict[str, Dict[str, Any]] = {}
        
        # Technology adoption tracking
        self.implemented_technologies: Dict[str, datetime] = {}
        self.technology_performance: Dict[str, Dict[str, Any]] = {}
        
        # Research scheduling and planning
        self.research_queue: List[str] = []
        self.research_priorities: Dict[str, int] = {}
        self.long_term_strategy: Dict[str, Any] = {}
        
        # Achievement and milestone tracking
        self.research_achievements: List[Dict[str, Any]] = []
        self.breakthrough_discoveries: List[Dict[str, Any]] = []
        
        # Initialize system
        self._initialize_research_trees()
        
    def _initialize_research_trees(self):
        """Initialize research trees with technology data"""
        try:
            self._load_technology_definitions()
            self._setup_research_facilities()
            self._initialize_research_resources()
            self._calculate_initial_availability()
            
            if self.event_system:
                self._subscribe_to_events()
                
            self.logger.info("Research Trees system initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Error initializing research trees: {e}")
            self._create_basic_research_configuration()
    
    def _load_technology_definitions(self):
        """Load comprehensive technology tree definitions"""
        
        # Equipment Technology Tree
        equipment_techs = [
            {
                "tech_id": "animal_power",
                "tech_name": "Animal Power",
                "description": "Use of horses, oxen, and mules for agricultural work",
                "category": ResearchCategory.EQUIPMENT_TECHNOLOGY,
                "era": ResearchEra.TRADITIONAL,
                "complexity": ResearchComplexity.BASIC,
                "prerequisites": [],
                "base_research_time_days": 0,  # Starting technology
                "benefits": [
                    ResearchBenefit("unlock", "equipment", 1.0, "Unlocks animal-drawn implements")
                ],
                "equipment_unlocks": ["horse_drawn_plow", "ox_cart", "horse_harrow"],
                "status": ResearchStatus.COMPLETED  # Starting technology
            },
            {
                "tech_id": "steam_power",
                "tech_name": "Steam Power",
                "description": "Early mechanization using steam-powered tractors and threshing machines",
                "category": ResearchCategory.EQUIPMENT_TECHNOLOGY,
                "era": ResearchEra.MECHANIZATION,
                "complexity": ResearchComplexity.INTERMEDIATE,
                "prerequisites": [
                    ResearchPrerequisite("animal_power", "technology")
                ],
                "base_research_time_days": 180,
                "resources_required": [
                    ResearchResource(ResourceType.FUNDING, 15000, 15000, "Steam engine development"),
                    ResearchResource(ResourceType.RESEARCH_POINTS, 50, 50, "Mechanical engineering research")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "field_work", 1.5, "50% increase in field work capacity")
                ],
                "equipment_unlocks": ["steam_tractor", "steam_thresher"]
            },
            {
                "tech_id": "internal_combustion",
                "tech_name": "Internal Combustion Engine",
                "description": "Gasoline and diesel engines revolutionize farm mechanization",
                "category": ResearchCategory.EQUIPMENT_TECHNOLOGY,
                "era": ResearchEra.MECHANIZATION,
                "complexity": ResearchComplexity.ADVANCED,
                "prerequisites": [
                    ResearchPrerequisite("steam_power", "technology")
                ],
                "base_research_time_days": 365,
                "resources_required": [
                    ResearchResource(ResourceType.FUNDING, 50000, 50000, "Engine development and testing"),
                    ResearchResource(ResourceType.RESEARCH_POINTS, 150, 150, "Combustion research")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "field_work", 2.0, "100% increase in field work capacity"),
                    ResearchBenefit("unlock", "modern_implements", 1.0, "Unlocks modern farm implements")
                ],
                "equipment_unlocks": ["gasoline_tractor", "diesel_tractor", "combine_harvester"],
                "unlocks": ["hydraulic_systems", "pto_systems"]
            },
            {
                "tech_id": "hydraulic_systems",
                "tech_name": "Hydraulic Systems",
                "description": "Hydraulic lift and control systems for implements and attachments",
                "category": ResearchCategory.EQUIPMENT_TECHNOLOGY,
                "era": ResearchEra.MECHANIZATION,
                "complexity": ResearchComplexity.INTERMEDIATE,
                "prerequisites": [
                    ResearchPrerequisite("internal_combustion", "technology")
                ],
                "base_research_time_days": 120,
                "resources_required": [
                    ResearchResource(ResourceType.FUNDING, 25000, 25000, "Hydraulic system development"),
                    ResearchResource(ResourceType.RESEARCH_POINTS, 75, 75, "Fluid dynamics research")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "implement_control", 1.3, "30% improvement in implement operation")
                ],
                "equipment_unlocks": ["hydraulic_plow", "hydraulic_loader", "three_point_hitch"]
            },
            {
                "tech_id": "gps_guidance",
                "tech_name": "GPS Guidance Systems",
                "description": "Satellite-based navigation for precise field operations",
                "category": ResearchCategory.PRECISION_AGRICULTURE,
                "era": ResearchEra.PRECISION,
                "complexity": ResearchComplexity.ADVANCED,
                "prerequisites": [
                    ResearchPrerequisite("computer_systems", "technology"),
                    ResearchPrerequisite("satellite_technology", "technology")
                ],
                "base_research_time_days": 270,
                "resources_required": [
                    ResearchResource(ResourceType.FUNDING, 100000, 100000, "GPS receiver and software development"),
                    ResearchResource(ResourceType.RESEARCH_POINTS, 200, 200, "Navigation and positioning research"),
                    ResearchResource(ResourceType.PARTNERSHIPS, 1, 0, "Satellite technology partnership")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "field_accuracy", 1.8, "80% reduction in overlap and skips"),
                    ResearchBenefit("bonus", "fuel_efficiency", 0.15, "15% fuel savings")
                ],
                "equipment_unlocks": ["gps_tractor", "autosteer_system", "variable_rate_controller"],
                "unlocks": ["precision_planting", "variable_rate_application"]
            },
            {
                "tech_id": "autonomous_vehicles",
                "tech_name": "Autonomous Agricultural Vehicles",
                "description": "Fully autonomous tractors and implements for unmanned field operations",
                "category": ResearchCategory.EQUIPMENT_TECHNOLOGY,
                "era": ResearchEra.AUTONOMOUS,
                "complexity": ResearchComplexity.REVOLUTIONARY,
                "prerequisites": [
                    ResearchPrerequisite("gps_guidance", "technology"),
                    ResearchPrerequisite("artificial_intelligence", "technology"),
                    ResearchPrerequisite("sensor_networks", "technology")
                ],
                "base_research_time_days": 1095,  # 3 years
                "resources_required": [
                    ResearchResource(ResourceType.FUNDING, 500000, 500000, "Autonomous system development"),
                    ResearchResource(ResourceType.RESEARCH_POINTS, 1000, 1000, "AI and robotics research"),
                    ResearchResource(ResourceType.FACILITIES, 3, 0, "Advanced computing and testing facilities"),
                    ResearchResource(ResourceType.PARTNERSHIPS, 3, 0, "Technology partnerships")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "labor_reduction", 0.8, "80% reduction in operator time"),
                    ResearchBenefit("efficiency", "operation_precision", 2.5, "250% improvement in precision"),
                    ResearchBenefit("bonus", "24_hour_operation", 1.0, "Enable 24-hour field operations")
                ],
                "equipment_unlocks": ["autonomous_tractor", "robotic_harvester", "drone_swarms"]
            }
        ]
        
        # Crop Science Technology Tree
        crop_science_techs = [
            {
                "tech_id": "selective_breeding",
                "tech_name": "Selective Breeding",
                "description": "Traditional plant breeding through selection of superior traits",
                "category": ResearchCategory.CROP_SCIENCE,
                "era": ResearchEra.TRADITIONAL,
                "complexity": ResearchComplexity.BASIC,
                "prerequisites": [],
                "base_research_time_days": 730,  # 2 years for breeding cycles
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 30, 30, "Plant breeding research"),
                    ResearchResource(ResourceType.TIME, 730, 730, "Multiple growing seasons required")
                ],
                "benefits": [
                    ResearchBenefit("bonus", "yield", 0.1, "10% yield improvement"),
                    ResearchBenefit("unlock", "variety_development", 1.0, "Unlock variety development")
                ],
                "crop_unlocks": ["improved_corn", "improved_wheat", "improved_soybeans"],
                "unlocks": ["hybridization", "genetic_markers"]
            },
            {
                "tech_id": "hybridization",
                "tech_name": "Hybrid Crop Development",
                "description": "Development of hybrid crops with heterosis vigor",
                "category": ResearchCategory.CROP_SCIENCE,
                "era": ResearchEra.CHEMICAL,
                "complexity": ResearchComplexity.INTERMEDIATE,
                "prerequisites": [
                    ResearchPrerequisite("selective_breeding", "technology")
                ],
                "base_research_time_days": 1095,  # 3 years
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 100, 100, "Hybrid breeding research"),
                    ResearchResource(ResourceType.FUNDING, 75000, 75000, "Breeding program development"),
                    ResearchResource(ResourceType.FACILITIES, 1, 0, "Breeding facility required")
                ],
                "benefits": [
                    ResearchBenefit("bonus", "yield", 0.25, "25% yield improvement from hybrid vigor"),
                    ResearchBenefit("bonus", "uniformity", 0.3, "30% improvement in crop uniformity")
                ],
                "crop_unlocks": ["hybrid_corn", "hybrid_sorghum", "hybrid_sunflower"],
                "unlocks": ["marker_assisted_selection"]
            },
            {
                "tech_id": "genetic_engineering",
                "tech_name": "Genetic Engineering",
                "description": "Direct manipulation of crop genetics for desired traits",
                "category": ResearchCategory.BIOTECHNOLOGY,
                "era": ResearchEra.PRECISION,
                "complexity": ResearchComplexity.CUTTING_EDGE,
                "prerequisites": [
                    ResearchPrerequisite("marker_assisted_selection", "technology"),
                    ResearchPrerequisite("molecular_biology", "technology")
                ],
                "base_research_time_days": 1460,  # 4 years
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 500, 500, "Genetic engineering research"),
                    ResearchResource(ResourceType.FUNDING, 250000, 250000, "Laboratory and equipment costs"),
                    ResearchResource(ResourceType.FACILITIES, 2, 0, "Advanced molecular biology lab"),
                    ResearchResource(ResourceType.PARTNERSHIPS, 2, 0, "University partnerships")
                ],
                "benefits": [
                    ResearchBenefit("unlock", "transgenic_crops", 1.0, "Unlock transgenic crop varieties"),
                    ResearchBenefit("bonus", "pest_resistance", 0.5, "50% reduction in pest damage"),
                    ResearchBenefit("bonus", "herbicide_tolerance", 1.0, "Herbicide-tolerant varieties")
                ],
                "crop_unlocks": ["bt_corn", "roundup_ready_soybeans", "golden_rice"],
                "unlocks": ["gene_editing", "synthetic_biology"]
            }
        ]
        
        # Precision Agriculture Technology Tree
        precision_ag_techs = [
            {
                "tech_id": "soil_testing",
                "tech_name": "Scientific Soil Testing",
                "description": "Chemical analysis of soil nutrients and pH for precise fertilization",
                "category": ResearchCategory.SOIL_SCIENCE,
                "era": ResearchEra.CHEMICAL,
                "complexity": ResearchComplexity.BASIC,
                "prerequisites": [],
                "base_research_time_days": 60,
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 20, 20, "Soil chemistry research"),
                    ResearchResource(ResourceType.FUNDING, 5000, 5000, "Laboratory equipment")
                ],
                "benefits": [
                    ResearchBenefit("efficiency", "fertilizer_efficiency", 1.2, "20% improvement in fertilizer efficiency"),
                    ResearchBenefit("bonus", "soil_health", 0.1, "10% improvement in soil health monitoring")
                ],
                "technique_unlocks": ["grid_soil_sampling", "variable_fertilization"],
                "unlocks": ["precision_fertilization", "yield_mapping"]
            },
            {
                "tech_id": "yield_mapping",
                "tech_name": "Yield Mapping",
                "description": "GPS-based mapping of yield variations across fields",
                "category": ResearchCategory.PRECISION_AGRICULTURE,
                "era": ResearchEra.PRECISION,
                "complexity": ResearchComplexity.INTERMEDIATE,
                "prerequisites": [
                    ResearchPrerequisite("soil_testing", "technology"),
                    ResearchPrerequisite("gps_guidance", "technology")
                ],
                "base_research_time_days": 120,
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 75, 75, "Spatial analysis research"),
                    ResearchResource(ResourceType.FUNDING, 35000, 35000, "Yield monitoring equipment")
                ],
                "benefits": [
                    ResearchBenefit("unlock", "precision_management", 1.0, "Enable precision field management"),
                    ResearchBenefit("efficiency", "input_optimization", 1.3, "30% improvement in input optimization")
                ],
                "equipment_unlocks": ["yield_monitor", "gis_software"],
                "unlocks": ["variable_rate_application", "prescription_mapping"]
            },
            {
                "tech_id": "sensor_networks",
                "tech_name": "Wireless Sensor Networks",
                "description": "Network of field sensors for real-time crop and soil monitoring",
                "category": ResearchCategory.PRECISION_AGRICULTURE,
                "era": ResearchEra.DIGITAL,
                "complexity": ResearchComplexity.ADVANCED,
                "prerequisites": [
                    ResearchPrerequisite("yield_mapping", "technology"),
                    ResearchPrerequisite("wireless_communication", "technology")
                ],
                "base_research_time_days": 180,
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 150, 150, "Sensor technology research"),
                    ResearchResource(ResourceType.FUNDING, 80000, 80000, "Sensor network deployment"),
                    ResearchResource(ResourceType.PARTNERSHIPS, 1, 0, "Technology partnership")
                ],
                "benefits": [
                    ResearchBenefit("unlock", "real_time_monitoring", 1.0, "Real-time field condition monitoring"),
                    ResearchBenefit("efficiency", "irrigation_efficiency", 1.4, "40% improvement in irrigation efficiency"),
                    ResearchBenefit("bonus", "early_problem_detection", 0.3, "30% earlier detection of problems")
                ],
                "equipment_unlocks": ["soil_moisture_sensors", "weather_stations", "crop_sensors"],
                "unlocks": ["artificial_intelligence", "predictive_analytics"]
            }
        ]
        
        # Sustainability Technology Tree
        sustainability_techs = [
            {
                "tech_id": "crop_rotation",
                "tech_name": "Scientific Crop Rotation",
                "description": "Systematic rotation of crops to improve soil health and reduce pests",
                "category": ResearchCategory.SUSTAINABILITY,
                "era": ResearchEra.TRADITIONAL,
                "complexity": ResearchComplexity.BASIC,
                "prerequisites": [],
                "base_research_time_days": 365,  # Full rotation cycle
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 25, 25, "Agronomy research"),
                    ResearchResource(ResourceType.TIME, 365, 365, "Multi-season observation")
                ],
                "benefits": [
                    ResearchBenefit("bonus", "soil_health", 0.2, "20% improvement in soil health"),
                    ResearchBenefit("bonus", "pest_reduction", 0.15, "15% reduction in pest pressure"),
                    ResearchBenefit("bonus", "nitrogen_fixation", 0.1, "10% reduction in nitrogen fertilizer needs")
                ],
                "technique_unlocks": ["four_field_system", "nitrogen_fixing_rotation"],
                "unlocks": ["cover_crops", "integrated_pest_management"]
            },
            {
                "tech_id": "cover_crops",
                "tech_name": "Cover Crop Systems",
                "description": "Use of cover crops for soil protection and enhancement",
                "category": ResearchCategory.SUSTAINABILITY,
                "era": ResearchEra.CHEMICAL,
                "complexity": ResearchComplexity.INTERMEDIATE,
                "prerequisites": [
                    ResearchPrerequisite("crop_rotation", "technology")
                ],
                "base_research_time_days": 270,
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 60, 60, "Cover crop research"),
                    ResearchResource(ResourceType.FUNDING, 15000, 15000, "Cover crop seed and equipment")
                ],
                "benefits": [
                    ResearchBenefit("bonus", "soil_erosion", -0.4, "40% reduction in soil erosion"),
                    ResearchBenefit("bonus", "organic_matter", 0.25, "25% increase in soil organic matter"),
                    ResearchBenefit("bonus", "weed_suppression", 0.2, "20% reduction in weed pressure")
                ],
                "crop_unlocks": ["winter_rye", "crimson_clover", "radishes"],
                "unlocks": ["no_till_farming", "conservation_tillage"]
            },
            {
                "tech_id": "organic_certification",
                "tech_name": "Organic Farming Certification",
                "description": "Organic farming practices and certification systems",
                "category": ResearchCategory.SUSTAINABILITY,
                "era": ResearchEra.PRECISION,
                "complexity": ResearchComplexity.ADVANCED,
                "prerequisites": [
                    ResearchPrerequisite("cover_crops", "technology"),
                    ResearchPrerequisite("integrated_pest_management", "technology"),
                    ResearchPrerequisite("composting_systems", "technology")
                ],
                "base_research_time_days": 1095,  # 3-year transition period
                "resources_required": [
                    ResearchResource(ResourceType.RESEARCH_POINTS, 200, 200, "Organic farming research"),
                    ResearchResource(ResourceType.FUNDING, 50000, 50000, "Transition costs and certification"),
                    ResearchResource(ResourceType.TIME, 1095, 1095, "Organic transition period")
                ],
                "benefits": [
                    ResearchBenefit("bonus", "premium_pricing", 0.3, "30% price premium for organic products"),
                    ResearchBenefit("unlock", "organic_markets", 1.0, "Access to organic market channels"),
                    ResearchBenefit("bonus", "environmental_benefits", 1.0, "Environmental stewardship benefits")
                ],
                "technique_unlocks": ["organic_pest_control", "organic_fertilization"],
                "unlocks": ["biodynamic_farming", "regenerative_agriculture"]
            }
        ]
        
        # Combine all technology definitions
        all_technologies = (equipment_techs + crop_science_techs + 
                          precision_ag_techs + sustainability_techs)
        
        # Convert to ResearchTechnology objects
        for tech_dict in all_technologies:
            # Convert prerequisites
            prerequisites = []
            for prereq_data in tech_dict.get("prerequisites", []):
                if isinstance(prereq_data, dict):
                    prereq = ResearchPrerequisite(**prereq_data)
                else:
                    prereq = ResearchPrerequisite(prereq_data, "technology")
                prerequisites.append(prereq)
            tech_dict["prerequisites"] = prerequisites
            
            # Convert resources
            resources = []
            for resource_data in tech_dict.get("resources_required", []):
                if isinstance(resource_data, dict):
                    resource = ResearchResource(**resource_data)
                else:
                    resource = ResearchResource(resource_data[0], resource_data[1], 
                                              resource_data[1], "Research resource")
                resources.append(resource)
            tech_dict["resources_required"] = resources
            
            # Convert benefits
            benefits = []
            for benefit_data in tech_dict.get("benefits", []):
                if isinstance(benefit_data, dict):
                    benefit = ResearchBenefit(**benefit_data)
                else:
                    benefit = ResearchBenefit(benefit_data[0], benefit_data[1], 
                                            benefit_data[2], benefit_data[3])
                benefits.append(benefit)
            tech_dict["benefits"] = benefits
            
            # Create ResearchTechnology object
            technology = ResearchTechnology(**tech_dict)
            self.technologies[technology.tech_id] = technology
            
        self.logger.info(f"Loaded {len(self.technologies)} research technologies")
    
    def _setup_research_facilities(self):
        """Setup research facilities"""
        facility_data = [
            {
                "facility_id": "basic_lab",
                "facility_name": "Basic Research Laboratory",
                "facility_type": "lab",
                "research_categories_supported": [
                    ResearchCategory.CROP_SCIENCE, 
                    ResearchCategory.SOIL_SCIENCE
                ],
                "max_concurrent_projects": 2,
                "research_efficiency_multiplier": 1.0,
                "construction_cost": 50000,
                "annual_operating_cost": 15000,
                "equipment_value": 25000,
                "staff_capacity": 3
            },
            {
                "facility_id": "greenhouse_complex",
                "facility_name": "Greenhouse Research Complex",
                "facility_type": "greenhouse",
                "research_categories_supported": [
                    ResearchCategory.CROP_SCIENCE,
                    ResearchCategory.BIOTECHNOLOGY,
                    ResearchCategory.SUSTAINABILITY
                ],
                "max_concurrent_projects": 4,
                "research_efficiency_multiplier": 1.3,
                "construction_cost": 150000,
                "annual_operating_cost": 45000,
                "equipment_value": 75000,
                "staff_capacity": 6
            },
            {
                "facility_id": "field_station",
                "facility_name": "Agricultural Field Station",
                "facility_type": "field_station",
                "research_categories_supported": [
                    ResearchCategory.EQUIPMENT_TECHNOLOGY,
                    ResearchCategory.PRECISION_AGRICULTURE,
                    ResearchCategory.SUSTAINABILITY
                ],
                "max_concurrent_projects": 6,
                "research_efficiency_multiplier": 1.2,
                "construction_cost": 200000,
                "annual_operating_cost": 60000,
                "equipment_value": 100000,
                "staff_capacity": 8
            },
            {
                "facility_id": "computing_center",
                "facility_name": "Agricultural Computing Center",
                "facility_type": "computing",
                "research_categories_supported": [
                    ResearchCategory.PRECISION_AGRICULTURE,
                    ResearchCategory.BIOTECHNOLOGY,
                    ResearchCategory.FARM_MANAGEMENT
                ],
                "max_concurrent_projects": 8,
                "research_efficiency_multiplier": 1.5,
                "construction_cost": 300000,
                "annual_operating_cost": 90000,
                "equipment_value": 150000,
                "staff_capacity": 12
            }
        ]
        
        # Convert to ResearchFacility objects
        for facility_dict in facility_data:
            facility = ResearchFacility(**facility_dict)
            self.research_facilities[facility.facility_id] = facility
        
        self.logger.info(f"Setup {len(self.research_facilities)} research facilities")
    
    def _initialize_research_resources(self):
        """Initialize research resource pools"""
        # Initialize research points for each category
        for category in ResearchCategory:
            self.research_points[category] = 10.0  # Starting research points
        
        # Starting innovation points
        self.innovation_points = 50.0
        
        # Starting research funding
        self.total_research_funding = 25000.0
        
        self.logger.info("Research resources initialized")
    
    def _calculate_initial_availability(self):
        """Calculate which technologies are initially available"""
        for tech_id, technology in self.technologies.items():
            if self._check_prerequisites_met(technology):
                if technology.status == ResearchStatus.LOCKED:
                    technology.status = ResearchStatus.AVAILABLE
                    self.available_technologies.add(tech_id)
            
            # Mark starting technologies as completed
            if not technology.prerequisites:
                technology.status = ResearchStatus.COMPLETED
                self.completed_technologies.add(tech_id)
        
        self.logger.info(f"Initial availability: {len(self.available_technologies)} technologies available")
    
    def _check_prerequisites_met(self, technology: ResearchTechnology) -> bool:
        """Check if all prerequisites for a technology are met"""
        for prerequisite in technology.prerequisites:
            if prerequisite.prerequisite_type == "technology":
                if prerequisite.prerequisite_id not in self.completed_technologies:
                    return False
            elif prerequisite.prerequisite_type == "resource":
                # Check resource requirements
                if prerequisite.prerequisite_id == "funding":
                    if self.total_research_funding < prerequisite.required_amount:
                        return False
                elif prerequisite.prerequisite_id == "innovation_points":
                    if self.innovation_points < prerequisite.required_amount:
                        return False
        
        return True
    
    def _subscribe_to_events(self):
        """Subscribe to relevant events"""
        if self.event_system:
            self.event_system.subscribe('research_completed', self.handle_research_completion)
            self.event_system.subscribe('funding_allocated', self.handle_funding_allocation)
            self.event_system.subscribe('breakthrough_discovered', self.handle_breakthrough)
            self.event_system.subscribe('facility_constructed', self.handle_facility_construction)
    
    # Core research management methods
    
    def start_research_project(self, technology_id: str, researcher_id: str, 
                              funding_amount: float = 0) -> Dict[str, Any]:
        """Start a new research project"""
        try:
            if technology_id not in self.technologies:
                return {"success": False, "error": "Technology not found"}
            
            technology = self.technologies[technology_id]
            
            # Check if technology is available for research
            if technology.status != ResearchStatus.AVAILABLE:
                return {"success": False, "error": "Technology not available for research"}
            
            # Check prerequisites
            if not self._check_prerequisites_met(technology):
                return {"success": False, "error": "Prerequisites not met"}
            
            # Check resource requirements
            resource_check = self._check_resource_requirements(technology)
            if not resource_check["sufficient"]:
                return {"success": False, "error": "Insufficient resources", 
                       "requirements": resource_check["requirements"]}
            
            # Create research project
            project_id = f"proj_{technology_id}_{int(datetime.now().timestamp())}"
            
            # Calculate project timeline
            base_time = technology.base_research_time_days
            efficiency_multiplier = self.research_efficiency_multiplier
            
            # Apply facility bonuses if applicable
            facility_bonus = self._get_facility_bonus(technology.category)
            final_time = base_time / (efficiency_multiplier * facility_bonus)
            
            project = ResearchProject(
                project_id=project_id,
                technology_id=technology_id,
                project_name=f"Research: {technology.tech_name}",
                principal_researcher=researcher_id,
                start_date=datetime.now(),
                estimated_completion=datetime.now() + timedelta(days=int(final_time)),
                funding_allocated=funding_amount
            )
            
            # Consume resources
            self._consume_research_resources(technology)
            
            # Update technology status
            technology.status = ResearchStatus.IN_PROGRESS
            technology.date_started = datetime.now()
            technology.researcher_assigned = researcher_id
            
            # Add to tracking sets
            self.research_projects[project_id] = project
            self.in_progress_technologies.add(technology_id)
            self.available_technologies.discard(technology_id)
            
            # Publish event
            if self.event_system:
                self.event_system.publish('research_project_started', {
                    'project_id': project_id,
                    'technology_id': technology_id,
                    'researcher': researcher_id
                })
            
            self.logger.info(f"Research project started: {technology.tech_name}")
            
            return {"success": True, "project_id": project_id, "project": project}
            
        except Exception as e:
            self.logger.error(f"Error starting research project {technology_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def update_research_progress(self, project_id: str, progress_increment: float = 0.01) -> Dict[str, Any]:
        """Update progress on a research project"""
        try:
            if project_id not in self.research_projects:
                return {"success": False, "error": "Project not found"}
            
            project = self.research_projects[project_id]
            technology = self.technologies[project.technology_id]
            
            # Calculate progress increment based on various factors
            base_increment = progress_increment
            
            # Apply efficiency multipliers
            efficiency_multiplier = self.research_efficiency_multiplier
            facility_bonus = self._get_facility_bonus(technology.category)
            
            # Check for breakthrough opportunity
            breakthrough_chance = technology.breakthrough_chance
            if random.random() < breakthrough_chance:
                base_increment *= 2.0  # Double progress on breakthrough
                project.breakthrough_opportunities.append({
                    "date": datetime.now(),
                    "description": "Research breakthrough accelerated progress",
                    "bonus": 2.0
                })
            
            final_increment = base_increment * efficiency_multiplier * facility_bonus
            
            # Update progress
            project.progress_percentage = min(1.0, project.progress_percentage + final_increment)
            technology.research_progress = project.progress_percentage
            
            # Check for completion
            if project.progress_percentage >= 1.0:
                return self.complete_research_project(project_id)
            
            # Add milestone if significant progress
            if project.progress_percentage > 0.25 and not any(m.get("milestone") == "25_percent" 
                                                             for m in project.milestones):
                project.milestones.append({
                    "milestone": "25_percent",
                    "date": datetime.now(),
                    "description": "25% research progress achieved"
                })
            
            return {"success": True, "progress": project.progress_percentage}
            
        except Exception as e:
            self.logger.error(f"Error updating research progress {project_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def complete_research_project(self, project_id: str) -> Dict[str, Any]:
        """Complete a research project and apply benefits"""
        try:
            if project_id not in self.research_projects:
                return {"success": False, "error": "Project not found"}
            
            project = self.research_projects[project_id]
            technology = self.technologies[project.technology_id]
            
            # Mark project as completed
            project.actual_completion = datetime.now()
            project.progress_percentage = 1.0
            
            # Update technology status
            technology.status = ResearchStatus.COMPLETED
            technology.date_completed = datetime.now()
            technology.research_progress = 1.0
            
            # Update tracking sets
            self.completed_technologies.add(technology.tech_id)
            self.in_progress_technologies.discard(technology.tech_id)
            
            # Apply research benefits
            benefits_applied = self._apply_research_benefits(technology)
            
            # Unlock dependent technologies
            unlocked_technologies = self._unlock_dependent_technologies(technology)
            
            # Generate innovation points
            if technology.innovation_points_generated > 0:
                self.innovation_points += technology.innovation_points_generated
            
            # Update research efficiency if applicable
            if technology.research_efficiency_bonus > 0:
                self.research_efficiency_multiplier += technology.research_efficiency_bonus
            
            # Create completion record
            completion_record = {
                "technology_id": technology.tech_id,
                "technology_name": technology.tech_name,
                "completion_date": datetime.now(),
                "research_duration_days": (datetime.now() - technology.date_started).days,
                "benefits_applied": benefits_applied,
                "technologies_unlocked": unlocked_technologies,
                "innovation_points_gained": technology.innovation_points_generated
            }
            
            self.research_achievements.append(completion_record)
            
            # Publish completion event
            if self.event_system:
                self.event_system.publish('research_completed', {
                    'project_id': project_id,
                    'technology': technology,
                    'benefits': benefits_applied,
                    'unlocked': unlocked_technologies
                })
            
            self.logger.info(f"Research completed: {technology.tech_name}")
            
            return {
                "success": True,
                "completion_record": completion_record,
                "benefits_applied": benefits_applied,
                "unlocked_technologies": unlocked_technologies
            }
            
        except Exception as e:
            self.logger.error(f"Error completing research project {project_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def _check_resource_requirements(self, technology: ResearchTechnology) -> Dict[str, Any]:
        """Check if sufficient resources are available for research"""
        requirements_check = {
            "sufficient": True,
            "requirements": [],
            "shortfalls": []
        }
        
        for resource in technology.resources_required:
            requirement_info = {
                "resource_type": resource.resource_type.value,
                "required": resource.amount_required,
                "available": 0,
                "sufficient": False
            }
            
            if resource.resource_type == ResourceType.FUNDING:
                requirement_info["available"] = self.total_research_funding
                requirement_info["sufficient"] = self.total_research_funding >= resource.amount_required
            elif resource.resource_type == ResourceType.RESEARCH_POINTS:
                # Find the relevant category research points
                category_points = self.research_points.get(technology.category, 0)
                requirement_info["available"] = category_points
                requirement_info["sufficient"] = category_points >= resource.amount_required
            elif resource.resource_type == ResourceType.INNOVATION_POINTS:
                requirement_info["available"] = self.innovation_points
                requirement_info["sufficient"] = self.innovation_points >= resource.amount_required
            elif resource.resource_type == ResourceType.FACILITIES:
                suitable_facilities = self._count_suitable_facilities(technology.category)
                requirement_info["available"] = suitable_facilities
                requirement_info["sufficient"] = suitable_facilities >= resource.amount_required
            
            requirements_check["requirements"].append(requirement_info)
            
            if not requirement_info["sufficient"]:
                requirements_check["sufficient"] = False
                requirements_check["shortfalls"].append({
                    "resource": resource.resource_type.value,
                    "shortfall": resource.amount_required - requirement_info["available"]
                })
        
        return requirements_check
    
    def _consume_research_resources(self, technology: ResearchTechnology):
        """Consume resources required for research"""
        for resource in technology.resources_required:
            if resource.resource_type == ResourceType.FUNDING:
                self.total_research_funding -= resource.amount_consumed
            elif resource.resource_type == ResourceType.RESEARCH_POINTS:
                current_points = self.research_points.get(technology.category, 0)
                self.research_points[technology.category] = max(0, current_points - resource.amount_consumed)
            elif resource.resource_type == ResourceType.INNOVATION_POINTS:
                self.innovation_points -= resource.amount_consumed
    
    def _get_facility_bonus(self, category: ResearchCategory) -> float:
        """Get research efficiency bonus from facilities"""
        best_bonus = 1.0
        
        for facility in self.research_facilities.values():
            if (category in facility.research_categories_supported and
                facility.utilization_percentage < 1.0):  # Facility has capacity
                best_bonus = max(best_bonus, facility.research_efficiency_multiplier)
        
        return best_bonus
    
    def _count_suitable_facilities(self, category: ResearchCategory) -> int:
        """Count facilities suitable for research category"""
        count = 0
        for facility in self.research_facilities.values():
            if category in facility.research_categories_supported:
                count += 1
        return count
    
    def _apply_research_benefits(self, technology: ResearchTechnology) -> List[Dict[str, Any]]:
        """Apply benefits from completed research"""
        applied_benefits = []
        
        for benefit in technology.benefits:
            benefit_record = {
                "benefit_type": benefit.benefit_type,
                "benefit_target": benefit.benefit_target,
                "benefit_value": benefit.benefit_value,
                "description": benefit.benefit_description,
                "applied_date": datetime.now()
            }
            
            # Apply the benefit based on type
            if benefit.benefit_type == "efficiency":
                # Efficiency bonuses are typically multipliers
                self._apply_efficiency_bonus(benefit.benefit_target, benefit.benefit_value)
            elif benefit.benefit_type == "bonus":
                # Bonus values are typically additive
                self._apply_bonus(benefit.benefit_target, benefit.benefit_value)
            elif benefit.benefit_type == "unlock":
                # Unlocks enable new capabilities
                self._apply_unlock(benefit.benefit_target, benefit.benefit_value)
            
            applied_benefits.append(benefit_record)
        
        return applied_benefits
    
    def _apply_efficiency_bonus(self, target: str, value: float):
        """Apply efficiency bonus to target system"""
        # This would integrate with relevant game systems
        # For now, track in performance metrics
        if target not in self.technology_performance:
            self.technology_performance[target] = {}
        
        current_multiplier = self.technology_performance[target].get("efficiency_multiplier", 1.0)
        self.technology_performance[target]["efficiency_multiplier"] = current_multiplier * value
    
    def _apply_bonus(self, target: str, value: float):
        """Apply additive bonus to target system"""
        if target not in self.technology_performance:
            self.technology_performance[target] = {}
        
        current_bonus = self.technology_performance[target].get("bonus_value", 0.0)
        self.technology_performance[target]["bonus_value"] = current_bonus + value
    
    def _apply_unlock(self, target: str, value: float):
        """Apply unlock capability"""
        if target not in self.technology_performance:
            self.technology_performance[target] = {}
        
        self.technology_performance[target]["unlocked"] = True
        self.technology_performance[target]["unlock_date"] = datetime.now()
    
    def _unlock_dependent_technologies(self, completed_technology: ResearchTechnology) -> List[str]:
        """Unlock technologies that depend on the completed technology"""
        unlocked = []
        
        # Check all technologies for prerequisites met
        for tech_id, technology in self.technologies.items():
            if technology.status == ResearchStatus.LOCKED:
                if self._check_prerequisites_met(technology):
                    technology.status = ResearchStatus.AVAILABLE
                    self.available_technologies.add(tech_id)
                    unlocked.append(tech_id)
        
        # Also check explicitly listed unlocks
        for unlock_tech_id in completed_technology.unlocks:
            if unlock_tech_id in self.technologies:
                unlock_tech = self.technologies[unlock_tech_id]
                if unlock_tech.status == ResearchStatus.LOCKED:
                    if self._check_prerequisites_met(unlock_tech):
                        unlock_tech.status = ResearchStatus.AVAILABLE
                        self.available_technologies.add(unlock_tech_id)
                        if unlock_tech_id not in unlocked:
                            unlocked.append(unlock_tech_id)
        
        return unlocked
    
    # Research planning and management methods
    
    def create_research_strategy(self, focus_areas: List[ResearchCategory], 
                                time_horizon: int = 365) -> Dict[str, Any]:
        """Create a strategic research plan"""
        strategy = {
            "strategy_id": f"strategy_{int(datetime.now().timestamp())}",
            "focus_areas": [area.value for area in focus_areas],
            "time_horizon_days": time_horizon,
            "created_date": datetime.now(),
            "recommended_sequence": [],
            "resource_requirements": {},
            "expected_outcomes": [],
            "risk_assessment": {}
        }
        
        # Find optimal research sequence
        available_techs = [self.technologies[tech_id] for tech_id in self.available_technologies]
        focus_techs = [tech for tech in available_techs if tech.category in focus_areas]
        
        # Sort by complexity and dependency
        sorted_techs = sorted(focus_techs, key=lambda t: (
            t.complexity.value,
            len(t.prerequisites),
            t.base_research_time_days
        ))
        
        cumulative_time = 0
        total_funding = 0
        
        for tech in sorted_techs[:10]:  # Limit to top 10 recommendations
            if cumulative_time + tech.base_research_time_days <= time_horizon:
                tech_info = {
                    "technology_id": tech.tech_id,
                    "technology_name": tech.tech_name,
                    "category": tech.category.value,
                    "estimated_duration": tech.base_research_time_days,
                    "funding_required": sum(r.amount_required for r in tech.resources_required 
                                          if r.resource_type == ResourceType.FUNDING),
                    "priority_score": self._calculate_priority_score(tech),
                    "expected_roi": tech.roi_estimate_years
                }
                
                strategy["recommended_sequence"].append(tech_info)
                cumulative_time += tech.base_research_time_days
                total_funding += tech_info["funding_required"]
        
        # Calculate resource requirements
        strategy["resource_requirements"] = {
            "total_funding": total_funding,
            "total_time": cumulative_time,
            "research_points_needed": sum(
                sum(r.amount_required for r in tech.resources_required 
                    if r.resource_type == ResourceType.RESEARCH_POINTS)
                for tech in sorted_techs[:len(strategy["recommended_sequence"])]
            ),
            "facilities_needed": max(
                sum(r.amount_required for r in tech.resources_required 
                    if r.resource_type == ResourceType.FACILITIES)
                for tech in sorted_techs[:len(strategy["recommended_sequence"])]
            ) if sorted_techs else 0
        }
        
        return strategy
    
    def _calculate_priority_score(self, technology: ResearchTechnology) -> float:
        """Calculate priority score for technology"""
        score = 0.0
        
        # Base score from complexity (higher complexity = higher potential impact)
        complexity_scores = {
            ResearchComplexity.BASIC: 1.0,
            ResearchComplexity.INTERMEDIATE: 2.0,
            ResearchComplexity.ADVANCED: 3.0,
            ResearchComplexity.CUTTING_EDGE: 4.0,
            ResearchComplexity.REVOLUTIONARY: 5.0
        }
        score += complexity_scores.get(technology.complexity, 1.0)
        
        # Benefits score (more benefits = higher score)
        score += len(technology.benefits) * 0.5
        
        # Unlock score (unlocks more technologies = higher score)
        score += len(technology.unlocks) * 0.3
        
        # Equipment unlock score
        score += len(technology.equipment_unlocks) * 0.2
        
        # Innovation points score
        score += technology.innovation_points_generated * 0.1
        
        # Time penalty (longer research = lower immediate priority)
        time_penalty = min(technology.base_research_time_days / 365, 2.0)  # Max 2 year penalty
        score -= time_penalty
        
        # ROI bonus (better ROI = higher score)
        if technology.roi_estimate_years > 0:
            roi_bonus = min(5.0 / technology.roi_estimate_years, 2.0)  # Max 2 point bonus
            score += roi_bonus
        
        return max(score, 0.1)  # Minimum score of 0.1
    
    # Query and reporting methods
    
    def get_research_status_report(self) -> Dict[str, Any]:
        """Get comprehensive research status report"""
        report = {
            "summary": {
                "total_technologies": len(self.technologies),
                "completed_technologies": len(self.completed_technologies),
                "available_technologies": len(self.available_technologies),
                "in_progress_technologies": len(self.in_progress_technologies),
                "locked_technologies": len([t for t in self.technologies.values() 
                                          if t.status == ResearchStatus.LOCKED])
            },
            "resources": {
                "research_points": dict(self.research_points),
                "innovation_points": self.innovation_points,
                "total_funding": self.total_research_funding,
                "research_efficiency": self.research_efficiency_multiplier
            },
            "active_projects": [],
            "recent_completions": [],
            "facility_utilization": {},
            "category_progress": {}
        }
        
        # Active projects summary
        for project in self.research_projects.values():
            if project.actual_completion is None:  # In progress
                report["active_projects"].append({
                    "project_id": project.project_id,
                    "technology_name": self.technologies[project.technology_id].tech_name,
                    "progress": project.progress_percentage,
                    "estimated_completion": project.estimated_completion,
                    "researcher": project.principal_researcher
                })
        
        # Recent completions (last 30 days)
        cutoff_date = datetime.now() - timedelta(days=30)
        recent_completions = [
            achievement for achievement in self.research_achievements
            if achievement["completion_date"] > cutoff_date
        ]
        report["recent_completions"] = recent_completions
        
        # Facility utilization
        for facility_id, facility in self.research_facilities.items():
            report["facility_utilization"][facility_id] = {
                "name": facility.facility_name,
                "utilization": facility.utilization_percentage,
                "capacity": facility.max_concurrent_projects,
                "current_projects": len(facility.current_projects)
            }
        
        # Progress by category
        for category in ResearchCategory:
            category_techs = [t for t in self.technologies.values() if t.category == category]
            completed_in_category = [t for t in category_techs 
                                   if t.tech_id in self.completed_technologies]
            
            report["category_progress"][category.value] = {
                "total": len(category_techs),
                "completed": len(completed_in_category),
                "progress_percentage": len(completed_in_category) / len(category_techs) if category_techs else 0
            }
        
        return report
    
    def get_technology_details(self, technology_id: str) -> Dict[str, Any]:
        """Get detailed information about a specific technology"""
        if technology_id not in self.technologies:
            return {"error": "Technology not found"}
        
        technology = self.technologies[technology_id]
        
        details = {
            "technology": {
                "id": technology.tech_id,
                "name": technology.tech_name,
                "description": technology.description,
                "category": technology.category.value,
                "era": technology.era.value,
                "complexity": technology.complexity.value,
                "status": technology.status.value
            },
            "prerequisites": [
                {
                    "id": prereq.prerequisite_id,
                    "type": prereq.prerequisite_type,
                    "description": prereq.description,
                    "met": self._is_prerequisite_met(prereq)
                }
                for prereq in technology.prerequisites
            ],
            "resources_required": [
                {
                    "type": resource.resource_type.value,
                    "amount": resource.amount_required,
                    "description": resource.description,
                    "available": self._get_available_resource(resource.resource_type, technology.category)
                }
                for resource in technology.resources_required
            ],
            "benefits": [
                {
                    "type": benefit.benefit_type,
                    "target": benefit.benefit_target,
                    "value": benefit.benefit_value,
                    "description": benefit.benefit_description
                }
                for benefit in technology.benefits
            ],
            "unlocks": {
                "technologies": technology.unlocks,
                "equipment": technology.equipment_unlocks,
                "crops": technology.crop_unlocks,
                "techniques": technology.technique_unlocks
            },
            "research_info": {
                "base_time_days": technology.base_research_time_days,
                "breakthrough_chance": technology.breakthrough_chance,
                "innovation_points": technology.innovation_points_generated,
                "efficiency_bonus": technology.research_efficiency_bonus
            },
            "economics": {
                "development_cost": technology.development_cost,
                "implementation_cost": technology.implementation_cost,
                "annual_maintenance": technology.maintenance_cost_annual,
                "roi_estimate_years": technology.roi_estimate_years
            }
        }
        
        # Add progress information if research is in progress
        if technology.status == ResearchStatus.IN_PROGRESS:
            details["progress"] = {
                "percentage": technology.research_progress,
                "date_started": technology.date_started,
                "researcher": technology.researcher_assigned
            }
        
        # Add completion information if completed
        if technology.status == ResearchStatus.COMPLETED:
            details["completion"] = {
                "date_completed": technology.date_completed,
                "research_duration": (technology.date_completed - technology.date_started).days
                                   if technology.date_started else 0
            }
        
        return details
    
    def _is_prerequisite_met(self, prerequisite: ResearchPrerequisite) -> bool:
        """Check if a specific prerequisite is met"""
        if prerequisite.prerequisite_type == "technology":
            return prerequisite.prerequisite_id in self.completed_technologies
        elif prerequisite.prerequisite_type == "resource":
            available = self._get_available_resource_amount(prerequisite.prerequisite_id)
            return available >= (prerequisite.required_amount or 0)
        
        return False
    
    def _get_available_resource(self, resource_type: ResourceType, category: ResearchCategory) -> float:
        """Get available amount of a resource"""
        if resource_type == ResourceType.FUNDING:
            return self.total_research_funding
        elif resource_type == ResourceType.RESEARCH_POINTS:
            return self.research_points.get(category, 0)
        elif resource_type == ResourceType.INNOVATION_POINTS:
            return self.innovation_points
        elif resource_type == ResourceType.FACILITIES:
            return self._count_suitable_facilities(category)
        
        return 0.0
    
    def _get_available_resource_amount(self, resource_id: str) -> float:
        """Get available amount of a resource by ID"""
        if resource_id == "funding":
            return self.total_research_funding
        elif resource_id == "innovation_points":
            return self.innovation_points
        elif resource_id in [cat.value for cat in ResearchCategory]:
            category = ResearchCategory(resource_id)
            return self.research_points.get(category, 0)
        
        return 0.0
    
    # Event handlers
    
    def handle_research_completion(self, event_data: Dict[str, Any]):
        """Handle research completion events"""
        try:
            technology_id = event_data.get("technology_id")
            if technology_id in self.technologies:
                # Update any dependent systems
                technology = self.technologies[technology_id]
                self.logger.info(f"Research completed: {technology.tech_name}")
        
        except Exception as e:
            self.logger.error(f"Error handling research completion: {e}")
    
    def handle_funding_allocation(self, event_data: Dict[str, Any]):
        """Handle funding allocation events"""
        try:
            funding_amount = event_data.get("amount", 0)
            self.total_research_funding += funding_amount
            self.logger.info(f"Research funding increased by ${funding_amount}")
        
        except Exception as e:
            self.logger.error(f"Error handling funding allocation: {e}")
    
    def handle_breakthrough(self, event_data: Dict[str, Any]):
        """Handle breakthrough discovery events"""
        try:
            breakthrough_info = {
                "breakthrough_id": f"breakthrough_{int(datetime.now().timestamp())}",
                "date": datetime.now(),
                "description": event_data.get("description", "Research breakthrough"),
                "technology_affected": event_data.get("technology_id"),
                "innovation_points_gained": event_data.get("innovation_points", 100)
            }
            
            self.breakthrough_discoveries.append(breakthrough_info)
            self.innovation_points += breakthrough_info["innovation_points_gained"]
            
            self.logger.info(f"Research breakthrough: {breakthrough_info['description']}")
        
        except Exception as e:
            self.logger.error(f"Error handling breakthrough: {e}")
    
    # Utility methods
    
    def generate_research_points(self, category: ResearchCategory, amount: float):
        """Generate research points for a category"""
        current_points = self.research_points.get(category, 0)
        self.research_points[category] = current_points + amount
    
    def allocate_funding(self, amount: float):
        """Allocate funding to research"""
        self.total_research_funding += amount
    
    def get_available_technologies(self) -> List[str]:
        """Get list of technologies available for research"""
        return list(self.available_technologies)
    
    def get_completed_technologies(self) -> List[str]:
        """Get list of completed technologies"""
        return list(self.completed_technologies)
    
    def _create_basic_research_configuration(self):
        """Create minimal research configuration for fallback"""
        self.logger.warning("Creating basic research configuration")
        
        # Create basic technology
        basic_tech = ResearchTechnology(
            tech_id="basic_farming",
            tech_name="Basic Farming",
            description="Fundamental farming techniques",
            category=ResearchCategory.CROP_SCIENCE,
            era=ResearchEra.TRADITIONAL,
            complexity=ResearchComplexity.BASIC,
            status=ResearchStatus.COMPLETED
        )
        
        self.technologies["basic_farming"] = basic_tech
        self.completed_technologies.add("basic_farming")


# Global convenience functions
research_trees_instance = None

def get_research_trees():
    """Get the global research trees instance"""
    global research_trees_instance
    if research_trees_instance is None:
        research_trees_instance = ResearchTrees()
    return research_trees_instance

def start_research(technology_id: str, researcher_id: str, funding: float = 0):
    """Convenience function to start research"""
    return get_research_trees().start_research_project(technology_id, researcher_id, funding)

def get_research_status():
    """Convenience function to get research status"""
    return get_research_trees().get_research_status_report()

def get_available_research():
    """Convenience function to get available research"""
    return get_research_trees().get_available_technologies()

def create_research_plan(focus_areas: List[ResearchCategory], time_horizon: int = 365):
    """Convenience function to create research strategy"""
    return get_research_trees().create_research_strategy(focus_areas, time_horizon)